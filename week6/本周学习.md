# 本周学习

### 排序

* 插入排序
  - 从第一个元素开始，该元素可以认为已经被排序；
  - 取出下一个元素，在已经排序的元素序列中从后向前扫描；
  - 如果该元素大于新元素，将该元素移到下一位置；
  - 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
  - 将新元素插入到该位置后；
* 希尔排序
  - 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
  - 按增量序列个数k，对序列进行k 趟排序；
  - 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
* 归并排序 
  - 把长度为n的输入序列分成两个长度为n/2的子序列；
  - 对这两个子序列分别采用归并排序；
  - 将两个排序好的子序列合并成一个最终的排序序列。
* 快速排序
  - 从数列中挑出一个元素，称为 “基准”
  - 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作；
  - 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。
* 堆排序
  - 将初始待排序关键字序列构建成大顶堆，此堆为初始的无序区；
  - 将堆顶元素与最后一个元素R交换，此时得到新的无序区和新的有序区,且满足1,2…n-1<=n；
  - 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区调整为新堆，然后再次将1与无序区最后一个元素交换，得到新的无序区和新的有序区。不断重复此过程直到有序区的元素个数为n-1则整个排序过程完成。

### 分而治之

* 分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。
  
